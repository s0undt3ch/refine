{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Polishing and improving codebases automatically <p><code>refine</code> leverages the capabilities of libCST (Library for Concrete Syntax Trees), a Python library designed for parsing, manipulating, and generating Python code in a syntax-preserving way. It builds upon libCST's codemod module, which provides utilities for transforming code programmatically.</p>"},{"location":"#key-differentiators","title":"Key Differentiators","text":""},{"location":"#chained-codemod-execution","title":"Chained Codemod Execution","text":"<p><code>refine</code> enables running multiple <code>codemod</code>'s in a single CLI execution, streamlining workflows compared to libCST's one-codemod-per-execution approach.</p>"},{"location":"#priority-management","title":"Priority Management","text":"<p>Codemods are applied in a predefined order based on priorities defined by the modules. This ensures automatic logical sequencing of transformations.</p>"},{"location":"#streamlined-features","title":"Streamlined Features","text":""},{"location":"#single-pass-efficiency","title":"Single-Pass Efficiency","text":"<p>Chained execution minimizes redundant parsing and tree-building processes, improving efficiency for large-scale projects.</p>"},{"location":"#focus-on-developer-productivity","title":"Focus on Developer Productivity","text":"<p>By reducing the need for multiple executions, <code>refine</code> enhances developer workflows, especially in CI/CD pipelines or batch processing.</p>"},{"location":"codemods/","title":"Codemods","text":"<p>Codemods are python modules which provide a subclass of BaseCodemod, these classes are resposible for the code modifications.</p> <p>How to modify code can be read on libCST's documentation. Do note that our BaseCodemod differs from the libCST implementation. A good place to know how to implement a codemod can be see in this project's source tree under <code>src/refine/mods</code>.</p>"},{"location":"codemods/#included-codemods","title":"Included codemods","text":"<p>There are a few <code>codemod</code>'s included with the project, and issuing a <code>--list</code> on the <code>refine</code> CLI will show you what's available.</p> <pre><code>Available codemods:\n - cli-dashes-over-underscores: Replace `_` with `-`, ie, `--a-command` instead of `--a_command` in CLI commands.\n - sqlfmt: Format SQL queries using the `sqlfluff` python package.\n</code></pre>"},{"location":"codemods/#project-specific-codemods","title":"Project Specific Codemods","text":"<p>Probably some of the <code>codemods</code> of a project are quite tailored to the project and not that broad that could be contributed to the <code>refine</code> project.</p> <p>In such cases, a project can host their own codemods in a directory and configure the codemod_paths configuration setting.</p> <p>When properly configured, issuing <code>--list</code> will now include the project codemods.</p>"},{"location":"codemods/#testing-codemods","title":"Testing codemods","text":"<p>We include Modcase which is a dataclass prepared to test codemods from files which serve as before and after examples, as long as a pattern is followed.</p> <p>For example: <pre><code>from __future__ import annotations\n\nimport pathlib\n\nimport pytest\n\nfrom refine.mods.sql.fmt import FormatSQL\nfrom refine.mods.sql.fmt import FormatSQLConfig\nfrom refine.testing import Modcase\n\nFILES_PATH = pathlib.Path(__file__).parent.resolve() / \"files\" / \"fmt\"\n\n\ndef _get_case_id(case: Modcase) -&gt; str:\n    return case.name\n\n\ndef _get_cases() -&gt; list[Modcase]:\n    cases = []\n    for path in FILES_PATH.glob(\"*.py\"):\n        if \".updated.\" in path.name:\n            # We don't want to collect the .updated files\n            continue\n        cases.append(\n            Modcase(\n                path=path,\n                codemod=FormatSQL,\n                codemod_config=FormatSQLConfig(),\n            )\n        )\n    return cases\n\n\n@pytest.fixture(params=_get_cases(), ids=_get_case_id)\ndef fmt_case(request) -&gt; Modcase:\n    return request.param\n\n\ndef test_format_sql(fmt_case: Modcase):\n    fmt_case.assert_codemod()\n</code></pre></p> <p>The above <code>FILES_PATH</code> contains examples of code changes that are being tested, here's an example directory listing: <pre><code>Permissions Size User           Date Modified Name\n.rw-r--r--@  287 pedro.algarvio 16 Nov 12:44  \ue606 attribute-with-comment.py\n.rw-r--r--@  307 pedro.algarvio 16 Nov 12:40  \ue606 attribute-with-comment.updated.py\n.rw-r--r--@  210 pedro.algarvio 22 Nov 12:34  \ue606 bytestrings.py\n.rw-r--r--@  202 pedro.algarvio 22 Nov 12:34  \ue606 bytestrings.updated.py\n.rw-r--r--@ 2.4k pedro.algarvio 24 Nov 21:06  \ue606 case-when.py\n.rw-r--r--@ 2.8k pedro.algarvio 24 Nov 21:06  \ue606 case-when.updated.py\n.rw-r--r--@  293 pedro.algarvio 10 Nov 19:53  \ue606 funcall-with-comment.py\n.rw-r--r--@  313 pedro.algarvio 10 Nov 19:52  \ue606 funcall-with-comment.updated.py\n.rw-r--r--@  140 pedro.algarvio 10 Nov 12:26  \ue606 multiline-attribute.py\n.rw-r--r--@  132 pedro.algarvio 10 Nov 12:21  \ue606 multiline-attribute.updated.py\n.rw-r--r--@   28 pedro.algarvio  9 Nov 12:50  \ue606 oneline-attribute.py\n.rw-r--r--@   28 pedro.algarvio  9 Nov 12:50  \ue606 oneline-attribute.updated.py\n.rw-r--r--@ 1.6k pedro.algarvio 24 Nov 21:06  \ue606 weird-indentation-attr.py\n.rw-r--r--@ 1.6k pedro.algarvio 24 Nov 21:06  \ue606 weird-indentation-attr.updated.py\n.rw-r--r--@ 1.3k pedro.algarvio 22 Nov 12:34  \ue606 weird-indentation-call.py\n.rw-r--r--@ 1.3k pedro.algarvio 22 Nov 12:34  \ue606 weird-indentation-call.updated.py\n</code></pre></p> <p>To note that if a file before any codemods getting applied is called <code>a-file.py</code> then the updated file should be named <code>a-file.updated.py</code>.</p>"},{"location":"configuration/","title":"Configuration","text":"<p><code>refine</code> can be configured at the root of your repository with a <code>.refine.toml</code> file or in your project's <code>pyproject.toml</code>.</p> <p>All configuration options can seen on the Config class reference, but here are a few examples.</p>"},{"location":"configuration/#example-refinetoml","title":"Example <code>.refine.toml</code>","text":"<pre><code>[refine]\nselect = [\n    \"sqlfmt\",\n]\nexclude = [\n    # Exclude only makes sense if no select is defined, since all available\n    # codemods will be used, at which time we might want to exclude some.\n    \"sqlfmt\",\n]\ncodemod_paths = [\n    \".codemods/\"\n]\nprocess_pool_size = 2\n</code></pre>"},{"location":"configuration/#example-pyprojecttoml","title":"Example <code>pyproject.toml</code>","text":"<pre><code>[tool.refine]\nselect = [\n    \"sqlfmt\",\n]\nexclude = [\n    # Exclude only makes sense if no select is defined, since all available\n    # codemods will be used, at which time we might want to exclude some.\n    \"sqlfmt\",\n]\ncodemod_paths = [\n    \".codemods/\"\n]\nprocess_pool_size = 2\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-pip","title":"Using pip","text":"<p>To install the <code>refine</code> tool for use in the CLI, use the following command:</p> <pre><code>pip install re-code\n</code></pre>"},{"location":"installation/#using-pre-commit","title":"Using pre-commit","text":"<p>To use the <code>refine</code> tool with pre-commit, add the following configuration to your <code>.pre-commit-config.yaml</code> file:</p> <pre><code>- repo: https://github.com/s0undt3ch/refine\n  rev: v1.0.0  # Use the appropriate version or branch\n  hooks:\n    - id: refine\n</code></pre> <p>Then, install the pre-commit hook by running:</p> <pre><code>pre-commit install --install-hooks\n</code></pre> <p>This will set up the <code>refine</code> tool to run automatically on your codebase as part of the pre-commit hooks.</p>"},{"location":"reference/refine/abc/","title":"refine.abc","text":"<p>Abstract base classes for defining codemod types and their configurations.</p>"},{"location":"reference/refine/abc/#refine.abc.BaseConfig","title":"BaseConfig","text":"<p>               Bases: <code>Struct</code></p> <p>Base configuration class for codemoders.</p>"},{"location":"reference/refine/abc/#refine.abc.BaseConfig.exclude","title":"exclude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude: list[str] = field(default_factory=list)\n</code></pre> <p>List of glob patterns to exclude paths from being processed.</p>"},{"location":"reference/refine/abc/#refine.abc.BaseCodemod","title":"BaseCodemod","text":"<pre><code>BaseCodemod(\n    context: CodemodContext, config: CodemodConfigType\n)\n</code></pre> <p>               Bases: <code>VisitorBasedCodemodCommand</code>, <code>ABC</code>, <code>Generic[CodemodConfigType]</code></p> <p>Base class for codemoders.</p> Source code in <code>src/refine/abc.py</code> <pre><code>def __init__(self, context: CodemodContext, config: CodemodConfigType):\n    for pattern in config.exclude:\n        if TYPE_CHECKING:\n            assert context.filename is not None\n        if fnmatch.fnmatch(context.filename, pattern):\n            error_msg = f\"Excluded by pattern '{pattern}' defined in the '{self.NAME}' codemod configuration .\"\n            raise SkipFile(error_msg)\n    super().__init__(context)\n    self.config = config\n    self._add_imports: set[AddRemoveImport] = set()\n    self._remove_imports: set[AddRemoveImport] = set()\n    self.__post_codemod_init__()\n</code></pre>"},{"location":"reference/refine/abc/#refine.abc.BaseCodemod.get_short_description","title":"get_short_description  <code>classmethod</code>","text":"<pre><code>get_short_description() -&gt; str\n</code></pre> <p>Return a short description of the codemod.</p> <p>This short description is used in the CLI to list available codemods and should be a single line.</p> <p>By default, it returns the first line of the class docstring, override this method to provide a custom description.</p> Source code in <code>src/refine/abc.py</code> <pre><code>@classmethod\ndef get_short_description(cls) -&gt; str:\n    \"\"\"\n    Return a short description of the codemod.\n\n    This short description is used in the CLI to list available codemods and should be a single line.\n\n    By default, it returns the first line of the class docstring, override this method to provide a\n    custom description.\n    \"\"\"\n    doc = cls.__doc__\n    if doc is None:\n        error_msg = f\"Codemod {cls.__name__} must have a docstring to be used in the CLI.\"\n        raise TypeError(error_msg)\n    if TYPE_CHECKING:\n        assert doc is not None\n    return doc.strip().splitlines()[0].strip()\n</code></pre>"},{"location":"reference/refine/abc/#refine.abc.BaseCodemod.add_import","title":"add_import","text":"<pre><code>add_import(\n    module: str,\n    obj: str | None = None,\n    asname: str | None = None,\n) -&gt; None\n</code></pre> <p>Schedule an import to be added to the updated module, if not already present.</p> <p>This method has the same signature as add_needed_import, the only major difference is that we won't duplicate the imports even if you call this method multiple times, and, we pass the context when actually updating the imports.</p> Source code in <code>src/refine/abc.py</code> <pre><code>def add_import(self, module: str, obj: str | None = None, asname: str | None = None) -&gt; None:\n    \"\"\"\n    Schedule an import to be added to the updated module, if not already present.\n\n    This method has the same signature as [add_needed_import][libcst.codemod.visitors.AddImportsVisitor],\n    the only major difference is that we won't duplicate the imports even if you call this method multiple\n    times, and, we pass the [context][libcst.codemod.CodemodContext] when actually updating the imports.\n    \"\"\"\n    self._add_imports.add((module, obj, asname))\n</code></pre>"},{"location":"reference/refine/abc/#refine.abc.BaseCodemod.remove_import","title":"remove_import","text":"<pre><code>remove_import(\n    module: str,\n    obj: str | None = None,\n    asname: str | None = None,\n) -&gt; None\n</code></pre> <p>Schedule an import to be removed from the updated module, if present.</p> <p>This method has the same signature as remove_unused_import, the only major difference is that we won't schedule duplicate import removals even if you call this method multiple times, and, we pass the context when actually updating the imports.</p> Source code in <code>src/refine/abc.py</code> <pre><code>def remove_import(self, module: str, obj: str | None = None, asname: str | None = None) -&gt; None:\n    \"\"\"\n    Schedule an import to be removed from the updated module, if present.\n\n    This method has the same signature as [remove_unused_import][libcst.codemod.visitors.RemoveImportsVisitor],\n    the only major difference is that we won't schedule duplicate import removals even if you call this method\n    multiple times, and, we pass the [context][libcst.codemod.CodemodContext] when actually updating the imports.\n    \"\"\"\n    self._remove_imports.add((module, obj, asname))\n</code></pre>"},{"location":"reference/refine/cli/","title":"refine.cli","text":"<p>Utility to simplify rewriting python code.</p> <p>It can be used for one-off rewrites, or, to maintain code styling rules.</p>"},{"location":"reference/refine/cli/#refine.cli.CLI","title":"CLI","text":"<pre><code>CLI()\n</code></pre> <p>Command Line Interface for the Refine tool.</p> Source code in <code>src/refine/cli.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.files: list[pathlib.Path] = []\n    self.parser = self._setup_parser()\n</code></pre>"},{"location":"reference/refine/cli/#refine.cli.CLI.run","title":"run","text":"<pre><code>run(argv: list[str] | None = None) -&gt; NoReturn\n</code></pre> <p>Process the command line arguments and run the tool.</p> Source code in <code>src/refine/cli.py</code> <pre><code>def run(self, argv: list[str] | None = None) -&gt; NoReturn:\n    \"\"\"\n    Process the command line arguments and run the tool.\n    \"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n\n    args = self.parser.parse_args(argv)\n    if args.quiet:\n        logging.getLogger().setLevel(logging.ERROR)\n    elif args.verbose:\n        logging.getLogger().setLevel(logging.DEBUG)\n        logging.getLogger(\"py_walk\").setLevel(logging.INFO)\n\n    self.config = self._load_config(args.config)\n\n    if args.codemod_paths:\n        self.config.codemod_paths.clear()\n        for codemod_path in args.codemod_paths:\n            if not codemod_path.is_dir():\n                log.error(\"Codemod path %s is not a directory\", codemod_path)\n                self.parser.exit(status=1)\n            self.config.codemod_paths.append(str(codemod_path))\n\n    if args.codemod_paths_extend:\n        # Add the additional CLI passed codemod paths\n        for codemod_path in args.codemod_paths_extend:\n            if not codemod_path.is_dir():\n                log.error(\"Codemod path %s is not a directory\", codemod_path)\n                self.parser.exit(status=1)\n            strpath = str(codemod_path)\n            if strpath in self.config.codemod_paths:\n                continue\n            self.config.codemod_paths.append(strpath)\n\n    self.registry = Registry()\n    self.registry.load(self.config.codemod_paths)\n\n    available_codemods = {codemod.NAME: codemod.get_short_description() for codemod in self.registry.codemods()}\n\n    if args.select_codemod:\n        # Add any additional CLI passed selections\n        self.config.select[:] = list(args.select_codemod)\n        bad_codemods = set(self.config.select) - set(available_codemods)\n        if bad_codemods:\n            log.error(\"Invalid codemods selected: %s\", \", \".join(bad_codemods))\n            self.parser.exit(status=1)\n\n    if args.select_codemod_extend:\n        # Add any additional CLI passed selections\n        for name in args.select_codemod_extend:\n            if name not in self.config.select:\n                self.config.select.append(name)\n        bad_codemods = set(self.config.select) - set(available_codemods)\n        if bad_codemods:\n            log.error(\"Invalid codemods select extend: %s\", \", \".join(bad_codemods))\n            self.parser.exit(status=1)\n\n    if args.exclude_codemod:\n        # Add any additional CLI passed exclusions\n        self.config.exclude[:] = list(args.exclude_codemod)\n        bad_codemods = set(self.config.exclude) - set(available_codemods)\n        if bad_codemods:\n            log.error(\"Invalid codemods excluded: %s\", \", \".join(bad_codemods))\n            self.parser.exit(status=1)\n\n    if args.exclude_codemod_extend:\n        # Add any additional CLI passed exclusions\n        for name in args.exclude_codemod_extend:\n            if name not in self.config.exclude:\n                self.config.exclude.append(name)\n        bad_codemods = set(self.config.exclude) - set(available_codemods)\n        if bad_codemods:\n            log.error(\"Invalid codemods exclude extend: %s\", \", \".join(bad_codemods))\n            self.parser.exit(status=1)\n\n    if args.fail_fast:\n        self.config = msgspec.structs.replace(self.config, fail_fast=True)\n\n    if args.list_codemods:\n        log.info(\"Available codemods:\")\n        for name, description in sorted(available_codemods.items()):\n            # In case the description is comming from the docstring, we just really want the first line.\n            log.info(\" - %s: %s\", name, description.strip())\n        self.parser.exit()\n\n    repo_root: pathlib.Path = pathlib.Path(self.config.repo_root)\n    paths: list[pathlib.Path] = args.files\n    if not paths:\n        paths.append(repo_root)\n\n    ignore_patterns: list[str] = [\n        *self.config.exclude_patterns,\n        \"**/__pycache__/**\",\n    ]\n    gitignore_file = repo_root / \".gitignore\"\n    respect_gitignore: bool = args.respect_gitignore or self.config.respect_gitignore\n    if respect_gitignore and gitignore_file.exists():\n        ignore_patterns.extend(\n            pattern\n            for pattern in gitignore_file.read_text().splitlines()\n            if pattern and not pattern.startswith(\"#\")\n        )\n\n    for path in paths:\n        if path.is_file():\n            if self._append_path(path, repo_root=repo_root, files=self.files) is False:\n                self.parser.exit(status=1)\n            continue\n        for subpath in py_walk.walk(path, match=[\"*.py\"], mode=\"only-files\", ignore=ignore_patterns):\n            if self._append_path(subpath, repo_root=repo_root, files=self.files) is False:\n                self.parser.exit(status=1)\n\n    self.codemods = list(\n        self.registry.codemods(select_codemods=self.config.select, exclude_codemods=self.config.exclude)\n    )\n    if not self.codemods:\n        log.error(\"No codemods selected. Exiting.\")\n        self.parser.exit(status=1)\n\n    log.info(\"Selected codemods:\")\n    for codemod in self.codemods:\n        log.info(\" - %s: %s\", codemod.NAME, codemod.get_short_description())\n\n    try:\n        self.processor = Processor(config=self.config, registry=self.registry, codemods=self.codemods)\n    except InvalidConfigError as exc:\n        log.error(str(exc))  # noqa: TRY400\n        self.parser.exit(status=1)\n    try:\n        result: ParallelTransformResult = self.processor.process(self.files)\n        if result.failures:\n            self.parser.exit(status=1)\n    except RefineSystemExit as exc:\n        self.parser.exit(status=exc.code, message=exc.message)\n    except SystemExit as exc:\n        code: str | int | None = exc.code\n        if code is None:\n            self.parser.exit(status=1)\n        if isinstance(code, int):\n            self.parser.exit(status=code)\n        self.parser.exit(status=1, message=code)\n    except KeyboardInterrupt:\n        self.parser.exit(status=1)\n    self.parser.exit(status=0)\n</code></pre>"},{"location":"reference/refine/config/","title":"refine.config","text":"<p>Refine configuration.</p>"},{"location":"reference/refine/config/#refine.config.Config","title":"Config","text":"<p>               Bases: <code>Struct</code></p> <p>Main codemod configuration schema.</p>"},{"location":"reference/refine/config/#refine.config.Config.select","title":"select  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>select: list[str] = field(default_factory=list)\n</code></pre> <p>List of codemods to run.</p> <p>When no selection is made, all available codemods are run.</p>"},{"location":"reference/refine/config/#refine.config.Config.exclude","title":"exclude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude: list[str] = field(default_factory=list)\n</code></pre> <p>List of codemods to exclude.</p> <p>Only makes sense when <code>select</code> is empty and all codemods are run.</p>"},{"location":"reference/refine/config/#refine.config.Config.codemod_paths","title":"codemod_paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>codemod_paths: list[str] = field(default_factory=list)\n</code></pre> <p>List of additional paths to search for codemods.</p>"},{"location":"reference/refine/config/#refine.config.Config.process_pool_size","title":"process_pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>process_pool_size: int = field(default_factory=_cpu_count)\n</code></pre> <p>Number of processes to use for parallel processing. Defaults to the number of available CPUs.</p>"},{"location":"reference/refine/config/#refine.config.Config.repo_root","title":"repo_root  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>repo_root: str = field(default_factory=getcwd)\n</code></pre> <p>The root directory of the repository. Defaults to the current working directory.</p>"},{"location":"reference/refine/config/#refine.config.Config.fail_fast","title":"fail_fast  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fail_fast: bool = False\n</code></pre> <p>Stop processing as soon as possible after the first error.</p>"},{"location":"reference/refine/config/#refine.config.Config.respect_gitignore","title":"respect_gitignore  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>respect_gitignore: bool = False\n</code></pre> <p>Ignore files and directories listed in <code>.gitignore</code>.</p>"},{"location":"reference/refine/config/#refine.config.Config.exclude_patterns","title":"exclude_patterns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclude_patterns: list[str] = field(default_factory=list)\n</code></pre> <p>List of glob path patterns to exclude from processing. Note that the full path is checked against the glob.</p>"},{"location":"reference/refine/config/#refine.config.Config.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[str, Any]) -&gt; Config\n</code></pre> <p>Load the configuration from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>The configuration to load.</p> required <p>Returns:</p> Type Description <code>Config</code> <p>Config instance.</p> Source code in <code>src/refine/config.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; Config:\n    \"\"\"\n    Load the configuration from a dictionary.\n\n    Arguments:\n        data: The configuration to load.\n\n    Returns:\n        Config instance.\n    \"\"\"\n    try:\n        config = msgspec.convert(data, type=Config)\n        config.__remaining_config__.update({k: v for (k, v) in data.items() if k not in config.__struct_fields__})\n    except msgspec.ValidationError as exc:\n        error = f\"Invalid configuration: {exc}\"\n        raise InvalidConfigError(error) from exc\n    else:\n        return config\n</code></pre>"},{"location":"reference/refine/config/#refine.config.Config.from_default_file","title":"from_default_file  <code>classmethod</code>","text":"<pre><code>from_default_file(path: Path) -&gt; Config\n</code></pre> <p>Load the configuration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the configuration file.</p> required <p>Returns:</p> Type Description <code>Config</code> <p>Config instance.</p> Source code in <code>src/refine/config.py</code> <pre><code>@classmethod\ndef from_default_file(cls, path: Path) -&gt; Config:\n    \"\"\"\n    Load the configuration from a file.\n\n    Arguments:\n        path: The path to the configuration file.\n\n    Returns:\n        Config instance.\n    \"\"\"\n    try:\n        data = tomllib.loads(path.read_text(encoding=\"utf-8\"))\n    except tomllib.TOMLDecodeError as exc:\n        error = f\"Unable to parse {path}: {exc}\"\n        raise ConfigLoadError(error) from exc\n    else:\n        return cls.from_dict(data)\n</code></pre>"},{"location":"reference/refine/config/#refine.config.Config.from_pyproject_file","title":"from_pyproject_file  <code>classmethod</code>","text":"<pre><code>from_pyproject_file(path: Path) -&gt; Config\n</code></pre> <p>Load the configuration from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the configuration file.</p> required <p>Returns:</p> Type Description <code>Config</code> <p>Config instance.</p> Source code in <code>src/refine/config.py</code> <pre><code>@classmethod\ndef from_pyproject_file(cls, path: Path) -&gt; Config:\n    \"\"\"\n    Load the configuration from a file.\n\n    Arguments:\n        path: The path to the configuration file.\n\n    Returns:\n        Config instance.\n    \"\"\"\n    try:\n        data = tomllib.loads(path.read_text(encoding=\"utf-8\"))\n    except tomllib.TOMLDecodeError as exc:\n        error = f\"Unable to parse {path}: {exc}\"\n        raise ConfigLoadError(error) from exc\n    else:\n        return cls.from_dict(data.get(\"tool\", {}).get(\"refine\", {}))\n</code></pre>"},{"location":"reference/refine/config/#refine.config.Config.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict[str, Any]\n</code></pre> <p>Convert the configuration to a dictionary.</p> Source code in <code>src/refine/config.py</code> <pre><code>def as_dict(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Convert the configuration to a dictionary.\n    \"\"\"\n    return {k: getattr(self, k) for k in self.__struct_fields__}\n</code></pre>"},{"location":"reference/refine/exc/","title":"refine.exc","text":"<p>Refine related exceptions.</p>"},{"location":"reference/refine/exc/#refine.exc.RefineError","title":"RefineError","text":"<p>               Bases: <code>Exception</code></p> <p>Refine specific exception.</p>"},{"location":"reference/refine/exc/#refine.exc.InvalidConfigError","title":"InvalidConfigError","text":"<p>               Bases: <code>ValidationError</code></p> <p>Validation error.</p>"},{"location":"reference/refine/exc/#refine.exc.ConfigLoadError","title":"ConfigLoadError","text":"<pre><code>ConfigLoadError(message: str)\n</code></pre> <p>               Bases: <code>RefineError</code></p> <p>Configuration loading error.</p> Source code in <code>src/refine/exc.py</code> <pre><code>def __init__(self, message: str):\n    super().__init__(message)\n    self.message = message\n</code></pre>"},{"location":"reference/refine/exc/#refine.exc.RefineSystemExit","title":"RefineSystemExit","text":"<pre><code>RefineSystemExit(code: int, message: str | None = None)\n</code></pre> <p>               Bases: <code>SystemExit</code></p> <p>Refine system exit exception that accepts a message argument.</p> Source code in <code>src/refine/exc.py</code> <pre><code>def __init__(self, code: int, message: str | None = None):\n    if TYPE_CHECKING:\n        assert code is not None\n        assert isinstance(code, int)\n    super().__init__(code)\n    self.message = message\n</code></pre>"},{"location":"reference/refine/processor/","title":"refine.processor","text":"<p>Refine processor.</p> <p>A fair chunk of this module just piggybacks on what libCST does, we just adapt to our own way of processing the files.</p>"},{"location":"reference/refine/processor/#refine.processor.ParallelTransformResult","title":"ParallelTransformResult  <code>dataclass</code>","text":"<pre><code>ParallelTransformResult(\n    successes: int,\n    failures: int,\n    warnings: int,\n    skips: int,\n    changed: int,\n)\n</code></pre> <p>This is a copy of :class:<code>~libcst.codemod._cli.ParallelTransformResult</code> with an extra <code>changed</code> field.</p>"},{"location":"reference/refine/processor/#refine.processor.Processor","title":"Processor","text":"<pre><code>Processor(\n    config: Config,\n    registry: Registry,\n    codemods: list[type[BaseCodemod]],\n)\n</code></pre> <p>Refine codemod processor.</p> Source code in <code>src/refine/processor.py</code> <pre><code>def __init__(self, config: Config, registry: Registry, codemods: list[type[BaseCodemod]]) -&gt; None:\n    self.config = config\n    self.registry = registry\n    self.codemods = codemods\n    codemod_configs = {}\n    for codemod in codemods:\n        config_dict = config.__remaining_config__.get(codemod.NAME, {})\n        try:\n            codemod_config_cls = codemod.CONFIG_CLS\n        except AttributeError:\n            codemod_config = BaseConfig()\n        else:\n            try:\n                codemod_config = msgspec.convert(config_dict, codemod_config_cls)\n            except msgspec.ValidationError as exc:\n                error_msg = f\"Invalid configuration for codemod {codemod.NAME}: {exc}\"\n                raise InvalidConfigError(error_msg) from exc\n        codemod_configs[codemod.NAME] = codemod_config\n    self.codemod_configs = codemod_configs\n</code></pre>"},{"location":"reference/refine/processor/#refine.processor.Processor.process","title":"process","text":"<pre><code>process(files: list[Path]) -&gt; ParallelTransformResult\n</code></pre> <p>Process the passed in list of paths.</p> Source code in <code>src/refine/processor.py</code> <pre><code>def process(self, files: list[Path]) -&gt; ParallelTransformResult:\n    \"\"\"\n    Process the passed in list of paths.\n    \"\"\"\n    _files = sorted({str(fpath) for fpath in files})\n    total = len(_files)\n    progress = Progress(enabled=True, total=total)\n    chunk_size = 4\n    jobs = min(\n        self.config.process_pool_size,\n        (len(_files) + chunk_size - 1) // chunk_size,\n    )\n    if jobs &lt; 1:\n        error = \"Must have at least one job to process!\"\n        raise RefineSystemExit(code=1, message=error)\n\n    if total == 0:\n        return ParallelTransformResult(successes=0, failures=0, skips=0, warnings=0, changed=0)\n\n    pool_impl: partial[Pool] | type[DummyPool]\n    if total == 1 or jobs == 1:\n        # Simple case, we should not pay for process overhead.\n        # Let's just use a dummy synchronous pool.\n        jobs = 1\n        pool_impl = DummyPool\n    else:\n        pool_impl = partial(multiprocessing.Pool, maxtasksperchild=chunk_size)\n        # Warm the parser, pre-fork.\n        cst.parse_module(\"\")\n\n    inherited_dependencies: set[ProviderT] = set()\n    for codemod in self.codemods:\n        for dependency in codemod.get_inherited_dependencies():\n            inherited_dependencies.add(dependency)\n\n    metadata_manager = FullRepoManager(\n        self.config.repo_root,\n        _files,\n        list(inherited_dependencies),\n    )\n    metadata_manager.resolve_cache()\n\n    successes: int = 0\n    failures: int = 0\n    warnings: int = 0\n    skips: int = 0\n    changed: int = 0\n\n    with pool_impl(processes=jobs) as p:\n        try:\n            for result in p.imap_unordered(\n                partial(self._process_path, metadata_manager), _files, chunksize=chunk_size\n            ):\n                # Print an execution result, keep track of failures\n                _print_parallel_result(\n                    result,\n                    progress,\n                    repo_root=self.config.repo_root,\n                    unified_diff=False,\n                    show_changed=True,\n                    show_successes=False,\n                    hide_generated=True,\n                    hide_blacklisted=True,\n                )\n                progress.print(successes + failures + skips)\n\n                if isinstance(result.transform_result, TransformFailure):\n                    failures += 1\n                elif isinstance(result.transform_result, TransformSuccess):\n                    successes += 1\n                    if result.changed:\n                        changed += 1\n                elif isinstance(result.transform_result, (TransformExit, TransformSkip)):\n                    skips += 1\n\n                if isinstance(result.transform_result, TransformFailure) and self.config.fail_fast:\n                    break\n\n                warnings += len(result.transform_result.warning_messages)\n        finally:\n            progress.clear()\n\n    # Return whether there was one or more failure.\n    return ParallelTransformResult(\n        successes=successes, failures=failures, skips=skips, warnings=warnings, changed=changed\n    )\n</code></pre>"},{"location":"reference/refine/registry/","title":"refine.registry","text":"<p>Refine registry.</p> <p>This holds the information about what codemods are available to be used.</p>"},{"location":"reference/refine/registry/#refine.registry.Registry","title":"Registry","text":"<pre><code>Registry()\n</code></pre> <p>Registry class to hold all available codemods.</p> Source code in <code>src/refine/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._codemods: list[type[BaseCodemod]] = []\n</code></pre>"},{"location":"reference/refine/registry/#refine.registry.Registry.load","title":"load","text":"<pre><code>load(search_paths: list[str]) -&gt; None\n</code></pre> <p>Load all available codemods.</p> Source code in <code>src/refine/registry.py</code> <pre><code>def load(self, search_paths: list[str]) -&gt; None:\n    \"\"\"\n    Load all available codemods.\n    \"\"\"\n    self._codemods[:] = sorted(self._load(search_paths).values(), key=operator.attrgetter(\"PRIORITY\"))\n</code></pre>"},{"location":"reference/refine/registry/#refine.registry.Registry.codemods","title":"codemods","text":"<pre><code>codemods(\n    exclude_codemods: Iterable[str] = (),\n    select_codemods: Iterable[str] = (),\n) -&gt; Iterator[type[BaseCodemod]]\n</code></pre> <p>Returns all available codemods, optionally skipping those passed in <code>excluded_names</code>.</p> Source code in <code>src/refine/registry.py</code> <pre><code>def codemods(\n    self, exclude_codemods: Iterable[str] = (), select_codemods: Iterable[str] = ()\n) -&gt; Iterator[type[BaseCodemod]]:\n    \"\"\"\n    Returns all available codemods, optionally skipping those passed in `excluded_names`.\n    \"\"\"\n    for codemod in self._codemods:\n        if exclude_codemods and codemod.NAME in exclude_codemods:\n            continue\n        if select_codemods and codemod.NAME not in select_codemods:\n            continue\n        yield codemod\n</code></pre>"},{"location":"reference/refine/testing/","title":"refine.testing","text":"<p>Refine testing support.</p>"},{"location":"reference/refine/testing/#refine.testing.Modcase","title":"Modcase  <code>dataclass</code>","text":"<pre><code>Modcase(\n    *,\n    path: Path,\n    codemod: type[BaseCodemod],\n    codemod_config: BaseConfig,\n)\n</code></pre>"},{"location":"reference/refine/testing/#refine.testing.Modcase.assert_codemod","title":"assert_codemod","text":"<pre><code>assert_codemod(expected_skip: bool = False) -&gt; None\n</code></pre> <p>This assertion is inspired by libCST's TestClass implementation.</p> Source code in <code>src/refine/testing.py</code> <pre><code>def assert_codemod(self, expected_skip: bool = False) -&gt; None:\n    \"\"\"\n    This assertion is inspired by libCST's TestClass implementation.\n    \"\"\"\n    log.debug(\"Testing %s\", self)\n    if self.require_changes:\n        # Make sure the original content does not match the updated content\n        assert self.original != self.updated\n    else:\n        # Make sure the original content matches the updated content\n        assert self.original == self.updated\n    context = CodemodContext(filename=str(self.path))\n    transform_instance = self.codemod(context, self.codemod_config)\n    input_tree = parse_module(self.original, config=PartialParserConfig())\n    try:\n        output_tree = transform_instance.transform_module(input_tree)\n    except SkipFile:\n        if not expected_skip:\n            raise\n        output_tree = input_tree\n    else:\n        if expected_skip:\n            error = \"Expected SkipFile but was not raised\"\n            raise AssertionError(error)\n\n    if self.require_changes:\n        # Make sure changes were made\n        assert output_tree.code != self.original\n    else:\n        # Make sure no changes were made\n        assert output_tree.code == self.original\n\n    # Match what we have on file\n    assert output_tree.code == self.updated\n</code></pre>"},{"location":"reference/refine/utils/","title":"refine.utils","text":"<p>Refine utilities.</p>"},{"location":"reference/refine/utils/#refine.utils.evaluated_string","title":"evaluated_string  <code>cached</code>","text":"<pre><code>evaluated_string(node: SimpleString) -&gt; str | None\n</code></pre> <p>Evaluate a SimpleString node into a python string.</p> Source code in <code>src/refine/utils.py</code> <pre><code>@cache\ndef evaluated_string(node: cst.SimpleString) -&gt; str | None:\n    \"\"\"\n    Evaluate a SimpleString node into a python string.\n    \"\"\"\n    try:\n        evaluated_string = literal_eval(node.value)\n    except Exception:  # noqa: BLE001\n        # We can't evaluate the string, return None\n        return None\n    else:\n        if not isinstance(evaluated_string, str):\n            # We only want strings\n            return None\n        return evaluated_string\n</code></pre>"},{"location":"reference/refine/utils/#refine.utils.get_full_module_name","title":"get_full_module_name","text":"<pre><code>get_full_module_name(module: Module) -&gt; str\n</code></pre> <p>Return a fully qualified name of a module.</p> Source code in <code>src/refine/utils.py</code> <pre><code>def get_full_module_name(module: cst.Module) -&gt; str:\n    \"\"\"\n    Return a fully qualified name of a module.\n    \"\"\"\n    parts: list[str] = []\n    while isinstance(module, cst.Attribute):\n        parts.insert(0, module.attr.value)\n        module = module.value\n    if isinstance(module, cst.Name):\n        parts.insert(0, module.value)\n    return \".\".join(parts)\n</code></pre>"},{"location":"reference/refine/mods/cli/flags/","title":"refine.mods.cli.flags","text":"<p>This codemod enforces the use of dashes over underscores in CLI arguments.</p> <p>For example, it will transform this code: <pre><code>parser.add_argument(\"--a_command\")\n</code></pre> into this code: <pre><code>parser.add_argument(\"--a-command\")\n</code></pre></p> <p>It handles all CLI arguments by looking for strings matching the pattern <code>--[\\w]+_[\\w]+</code> that are arguments to a function call.</p>"},{"location":"reference/refine/mods/cli/flags/#refine.mods.cli.flags.CliDashesConfig","title":"CliDashesConfig","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Config for the <code>CliDashes</code> codemod.</p>"},{"location":"reference/refine/mods/cli/flags/#refine.mods.cli.flags.CliDashes","title":"CliDashes","text":"<pre><code>CliDashes(\n    context: CodemodContext, config: CodemodConfigType\n)\n</code></pre> <p>               Bases: <code>BaseCodemod</code></p> <p>Replace <code>_</code> with <code>-</code>, ie, <code>--a-command</code> instead of <code>--a_command</code> in CLI commands.</p> Source code in <code>src/refine/abc.py</code> <pre><code>def __init__(self, context: CodemodContext, config: CodemodConfigType):\n    for pattern in config.exclude:\n        if TYPE_CHECKING:\n            assert context.filename is not None\n        if fnmatch.fnmatch(context.filename, pattern):\n            error_msg = f\"Excluded by pattern '{pattern}' defined in the '{self.NAME}' codemod configuration .\"\n            raise SkipFile(error_msg)\n    super().__init__(context)\n    self.config = config\n    self._add_imports: set[AddRemoveImport] = set()\n    self._remove_imports: set[AddRemoveImport] = set()\n    self.__post_codemod_init__()\n</code></pre>"},{"location":"reference/refine/mods/sql/fmt/","title":"refine.mods.sql.fmt","text":"<p>SQL Formatting codemod.</p> <p>This codemod uses the sqlfluff python package to format SQL queries.</p>"},{"location":"reference/refine/mods/sql/fmt/#refine.mods.sql.fmt.FormatSQLConfig","title":"FormatSQLConfig","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for the SQL Formatting codemod.</p>"},{"location":"reference/refine/mods/sql/fmt/#refine.mods.sql.fmt.FormatSQLConfig.dialect","title":"dialect  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dialect: str = 'ansi'\n</code></pre> <p>The SQL dialect to use when formatting the SQL queries.</p>"},{"location":"reference/refine/mods/sql/fmt/#refine.mods.sql.fmt.FormatSQLConfig.sqlfluff_config_file","title":"sqlfluff_config_file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqlfluff_config_file: str = str(\n    BUILNTIN_SQLFLUFF_CONFIG_FILE\n)\n</code></pre> <p>The path to a sqlfluff configuration file.</p> <p>If not provided, a default, opionated, configuration will be used.</p>"},{"location":"reference/refine/mods/sql/fmt/#refine.mods.sql.fmt.FormatSQL","title":"FormatSQL","text":"<pre><code>FormatSQL(\n    context: CodemodContext, config: CodemodConfigType\n)\n</code></pre> <p>               Bases: <code>BaseCodemod[FormatSQLConfig]</code></p> <p>Format SQL queries using the <code>sqlfluff</code> python package.</p> Source code in <code>src/refine/abc.py</code> <pre><code>def __init__(self, context: CodemodContext, config: CodemodConfigType):\n    for pattern in config.exclude:\n        if TYPE_CHECKING:\n            assert context.filename is not None\n        if fnmatch.fnmatch(context.filename, pattern):\n            error_msg = f\"Excluded by pattern '{pattern}' defined in the '{self.NAME}' codemod configuration .\"\n            raise SkipFile(error_msg)\n    super().__init__(context)\n    self.config = config\n    self._add_imports: set[AddRemoveImport] = set()\n    self._remove_imports: set[AddRemoveImport] = set()\n    self.__post_codemod_init__()\n</code></pre>"},{"location":"reference/refine/mods/sql/utils/","title":"refine.mods.sql.utils","text":"<p>SQL mod related utility functions.</p>"},{"location":"reference/refine/mods/sql/utils/#refine.mods.sql.utils.match_sql_query","title":"match_sql_query","text":"<pre><code>match_sql_query(node: CSTNode) -&gt; Match[str] | None\n</code></pre> <p>Check if a node is a SQL query.</p> Source code in <code>src/refine/mods/sql/utils.py</code> <pre><code>def match_sql_query(node: cst.CSTNode) -&gt; re.Match[str] | None:\n    \"\"\"\n    Check if a node is a SQL query.\n    \"\"\"\n    if not isinstance(node, cst.SimpleString):\n        return None\n    evaluated_string = utils.evaluated_string(node)\n    if evaluated_string is None:\n        # We will only process strings\n        return None\n    return match_sql_query_string(evaluated_string)\n</code></pre>"},{"location":"reference/refine/mods/sql/utils/#refine.mods.sql.utils.match_sql_query_string","title":"match_sql_query_string  <code>cached</code>","text":"<pre><code>match_sql_query_string(string: str) -&gt; Match[str] | None\n</code></pre> <p>Check if a string is a SQL query.</p> Source code in <code>src/refine/mods/sql/utils.py</code> <pre><code>@cache\ndef match_sql_query_string(string: str) -&gt; re.Match[str] | None:\n    \"\"\"\n    Check if a string is a SQL query.\n    \"\"\"\n    return SQL_RE.match(string)\n</code></pre>"},{"location":"reference/refine/mods/sql/utils/#refine.mods.sql.utils.cst_module_has_query_strings","title":"cst_module_has_query_strings","text":"<pre><code>cst_module_has_query_strings(module: Module) -&gt; bool\n</code></pre> <p>Check if a module has SQL query strings.</p> Source code in <code>src/refine/mods/sql/utils.py</code> <pre><code>def cst_module_has_query_strings(module: cst.Module) -&gt; bool:\n    \"\"\"\n    Check if a module has SQL query strings.\n    \"\"\"\n    try:\n        module.visit(_FindSQLStringsVisitor())\n    except _FoundSQLStringException:\n        return True\n    return False\n</code></pre>"}]}